<link rel="import" href="../bower_components/polymer/polymer-element.html">
<link rel="import" href="../bower_components/polymer/lib/utils/debounce.html">
<link rel="import" href="../bower_components/vaadin-combo-box/vaadin-combo-box-light.html">
<link rel="import" href="../bower_components/paper-input/paper-input.html">
<link rel="import" href="md-icons.html">
<link rel="import" href="type-ahead-style.html">
<dom-module id="type-ahead">
    <template>
        <style include="type-ahead-style md-icons">
            :host {
                display: block;
            }

                :host[hidden], :host.hidden {
                    display: none;
                }
        </style>
        <vaadin-combo-box-light id="combo"
                                attr-for-value="value"
                                allow-custom-value="[[allowCustomValue]]"
                                filter="{{filterText}}"
                                on-blur="_onBlur"
                                value="{{itemValue}}"
                                loading="[[loading]]"
                                overlay-vertical-offset="[[overlayVerticalOffset]]"
                                filtered-items="[[filteredItems]]"
                                items="[[items]]"
                                item-value-path="[[itemValuePath]]"
                                item-label-path="[[itemLabelPath]]"
                                item-display-path="[[itemDisplayPath]]"
                                hidden$="[[hidden]]"
                                on-custom-value-set="_onVaadinEventFired"
                                on-selected-item-changed="_onVaadinEventFired"
                                on-vaadin-dropdown-closed="_onVaadinEventFired"
                                on-vaadin-dropdown-opened="_onVaadinEventFired">

            <paper-input id="display"
                         label="[[label]]"
                         value="{{itemLabel}}"
                         on-keyup="_onKeypressed"
                         on-focus="_onPaperInputFocus"
                         no-label-float="[[noLabelFloat]]"
                         always-float-label="[[alwaysFloatLabel]]"
                         placeholder$="[[placeholder]]"
                         auto-validate$="[[autoValidate]]"
                         required="[[required]]"
                         disabled$="[[disabled]]"
                         invalid="{{invalid}}">
                <i suffix class="md-icon">arrow_drop_down</i>
            </paper-input>
            <template>
                <style>
                    :host {
                        color: red;
                    }
                </style>
                <span title="[[_getItemDisplayName(item)]]">[[_getItemDisplayName(item)]]</span>
            </template>
        </vaadin-combo-box-light>
    </template>
    <script>
        /**
         * `type-ahead`
         *
         *
         * @customElement
         * @polymer
         * @demo demo/index.html
         */
        let idx = 1;
        class TypeAhead extends Polymer.Element {
            constructor() {
                super();
                this.ACTION = {
                    OPENED: 'opened',
                    CLOSED: 'closed',
                    CHANGED: 'changed'
                };
                this.lastFilterText = undefined;
            }
            static get is() { return 'type-ahead'; }
            static get observers() {
                return [
                    '_onFilterTextChanged(filterText)',
                    '_onValueTextChanged(value, text)',
                    '_onDropdownListChanged(dropdownList)',
                    '_onLabelDisplayPathChanged(itemLabelPath,itemDisplayPath)'
                ];
            }
            connectedCallback() {
                super.connectedCallback();
                this._ensureAttribute('always-float-label', '');
                this.$.combo._prefillFocusedItemLabel = () => { return; }

                window['typeAhead' + idx] = this;
                idx++;
            }
            static get properties() {
                return {
                    label: String,
                    minimumSearchChar: { type: Number, value: 3 },
                    filterText: String,
                    placeholder: String,
                    alwaysFloatLabel: { type: Boolean, value: false },
                    disabled: { type: Boolean, value: false },
                    invalid: { type: Boolean, value: false },
                    autoValidate: { type: Boolean, value: false },
                    required: { type: Boolean, value: false },
                    filterService: { type: Boolean, value: false },
                    items: Array,
                    filteredItems: Array,
                    itemValuePath: String,
                    itemLabelPath: String,
                    itemDisplayPath: String,
                    lastFilterText: String,
                    minimumWidth: String,
                    value: { type: String, notify: true },
                    text: { type: String, notify: true }
                };
            }
            /*Dynamicall add removed observer*/
            /*_onFilterServiceChanged(filterService) {
                const propName = 'filterText';
                const methodName = '_onDynamicListFilterTextChanged';
                if (filterService) {
                    this._createPropertyObserver(propName, methodName, true);
                }
                else {
                    if (this.__observeEffects && this.__observeEffects.filterText && this.__observeEffects.filterText[0]) {
                        const effect = this.__observeEffects[propName][0];
                        this._removePropertyEffect(propName, '__observeEffects', effect);
                    }
                }
            }*/
            _onPaperInputFocus(e) {
                this.filterService && (this.loading = false);
            }
            _onKeypressed(e) {
                if (this.$.display.value === '') {
                    this.$.combo.selectedItem && this._clearSelectedItem();
                    this._clearFilteredItems();
                }
            }
            _clearSelectedItem() {
                this.setProperties({
                    'lastFilterText': '',
                    'selectedItem': null,
                    '$.combo.selectedItem': null
                });
            }
            _clearEventQueue() {
                this.lastFilterText = this.$.display.value;
                this.eventQueue = {};
            }

            _getActionFromEventName(name) {
                return (name.split('-')).pop();
            }

            _handleOpenedChangedClosedEvents() {
                if (this.eventQueue) {
                    const { opened, changed, closed } = this.eventQueue;

                    if (opened && changed && closed) {
                        const { label, value, fromParent } = this._getItemValueLabel(changed.value);
                        if (this.srcOfChanged !== 'top') {
                            this.srcOfChanged = 'bottom';
                            this.setProperties({
                                text: label, value: value,
                                selectedItem: this.$.combo.selectedItem
                            });
                            this._dispatchEvent(changed.e);
                        }
                    }
                    else if (opened && closed) {
                        if (this.selectedItem && this.selectedItem.fromParent) {
                            this.srcOfChanged = 'top';
                            const { value, label } = this._getItemValueLabel(this.selectedItem);
                            this._forceSetValueLabelToVaadin(value, label);
                        }
                    }

                    if (closed) {
                        this.lastFilterText = '';
                    }
                }
            }

            _onVaadinEventFired(e) {
                if (e) {
                    e.stopPropagation && e.stopPropagation();
                    const { type, target, detail } = e;
                    const value = detail.value;
                    const action = this._getActionFromEventName(type);
                    if (action === this.ACTION.OPENED) {
                        this._clearEventQueue();
                    }

                    /*Handle when parent set value and label to Vaadin and it is not found in the list*/
                    if (action === this.ACTION.CHANGED &&
                        this.srcOfChanged === 'top') {
                        this.srcOfChanged = undefined;
                        if (value === null && this.value) {

                        }
                        /*this.srcOfChanged = 'bottom';
                        this.selectedItem = value;
                        this.text = this.$.display.value;*/
                    }
                    else {
                        this.srcOfChanged = 'bottom';
                    }

                    if (this.eventQueue) {
                        this.eventQueue[action] = {
                            e: e,
                            value: value
                        }
                        this._debounce({
                            id: 'openedChangedClosedEvents',
                            fn: this._handleOpenedChangedClosedEvents
                        });
                    }
                }
            }

            _onDropdownListChanged(value) {
                if (this.filterService) {
                    this.filteredItems = value;
                    this.loading = false;
                }
                else {
                    this.items = value;
                }
            }

            _onValueTextChanged(value, label) {
                this._debounce({
                    id: 'valueText',
                    fn: this._forceSetValueLabelToVaadin.bind(this, value, label)
                });
            }
            _onStaticListFilterTextChanged(text) {
            }

            _onFilterTextChanged(text) {
                if (this.lastFilterText === undefined && text === '') {
                    this.itemLabel = undefined;
                    this.invalid = false;
                    return;
                }
                this.filterService && this._onDynamicListFilterTextChanged(text);
            }

            _onDynamicListFilterTextChanged(text) {
                
                if (text !== undefined && this.lastFilterText !== text) {
                    console.log('here', text);
                    this._debounce({
                        id: 'filterText', timeout: 400, fn: () => {
                            if (text.length == 0 || (text.length >= this.minimumSearchChar)) {
                                if (text !== this.lastFilterText) {
                                    this.loading = true;
                                    this.lastFilterText = text;
                                    this._clearFilteredItems();
                                    this._dispatchEvent({
                                        type: 'filter-changed',
                                        target: this, detail: { value: text }
                                    });
                                }
                            }
                        }
                    });
                }
            }

            _onBlur(e) {
                this._clearFilteredItems();
            }

            _getItemValueLabel(item) {
                const label = Polymer.Path.get(item, this.itemLabelPath);
                const value = Polymer.Path.get(item, this.itemValuePath);

                return { label, value };
            }

            _clearFilteredItems() {
                this.filteredItems = undefined;
            }

            _getItemDisplayName(item) {
                return item[this.itemDisplayPath];
            }
            _onLabelDisplayPathChanged() {
                this._debounce({
                    id: 'labelDisplayPath', fn: () => {
                        const { itemLabelPath: label, itemDisplayPath: display } = this;
                        if (label && !display) {
                            this.itemDisplayPath = label;
                        }
                        else if (!label && display) {
                            this.itemLabelPath = display;
                        }
                    }
                });
            }

            _forceSetValueLabelToVaadin(value, label) {
                const labelPath = '$.combo._inputElementValue';
                const valuePath = '$.combo.value';
                let vaadinItem = {};

                if (this.srcOfChanged !== 'bottom') {
                    this.srcOfChanged = 'top';
                    let vaadinItem = {};
                    let typeAheadItem = {};
                    let item = { fromParent: true };
                    if (value) {
                        vaadinItem[valuePath] = value;
                        item[this.itemValuePath] = value;
                    }
                    if (label) {
                        vaadinItem[labelPath] = label;
                        item[this.itemLabelPath] = label;
                    }
                    this.setProperties(Object.assign({}, vaadinItem, { selectedItem: item }));
                }
                else {
                    this.srcOfChanged = undefined;
                }
            }

            _debounce({ id, timeout, fn }) {
                if (!timeout) { timeout = 1; }
                const dbId = `dbid-${id}`;
                this[dbId] = Polymer.Debouncer.debounce(this[dbId],
                    Polymer.Async.timeOut.after(timeout),
                    fn.bind(this));
            }
            _dispatchEvent(e) {
                e.stopPropagation && e.stopPropagation();
                const { type, detail } = e;
                const event = new CustomEvent(type,
                    { bubbles: true, composed: true, detail });
                this.dispatchEvent(event);
            }
            validate() {
                return this.$.display.validate();
            }
        }

        window.customElements.define(TypeAhead.is, TypeAhead);
    </script>
</dom-module>
