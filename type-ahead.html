<link rel="import" href="../bower_components/polymer/polymer-element.html">
<link rel="import" href="../bower_components/polymer/lib/utils/debounce.html">
<link rel="import" href="../bower_components/vaadin-combo-box/vaadin-combo-box-light.html">
<link rel="import" href="../bower_components/paper-input/paper-input.html">
<link rel="import" href="md-icons.html">
<link rel="import" href="type-ahead-style.html">
<dom-module id="type-ahead">
    <template>
        <style include="type-ahead-style md-icons">
            :host {
                display: block;
            }

                :host[hidden], :host.hidden {
                    display: none;
                }
        </style>
        <vaadin-combo-box-light id="combo"
                                attr-for-value="value"
                                filter="{{filterText}}"
                                allow-custom-value
                                on-blur="_onBlur"
                                value="{{itemValue}}"
                                loading="[[loading]]"
                                overlay-vertical-offset="[[offset]]"
                                filtered-items="[[filteredItems]]"
                                items="[[items]]"
                                item-value-path="[[itemValuePath]]"
                                item-label-path="[[itemLabelPath]]"
                                item-display-path="[[itemDisplayPath]]"
                                hidden$="[[hidden]]"
                                on-custom-value-set="_onVaadinEventFired"
                                on-selected-item-changed="_onVaadinEventFired"
                                on-vaadin-dropdown-closed="_onVaadinEventFired"
                                on-vaadin-dropdown-opened="_onVaadinEventFired">

            <paper-input id="display"
                         label="[[label]]"
                         value="{{itemLabel}}"
                         on-keyup="_onKeypressed"
                         on-focus="_onPaperInputFocus"
                         no-label-float="[[noLabelFloat]]"
                         always-float-label="[[alwaysFloatLabel]]"
                         placeholder$="[[placeholder]]"
                         auto-validate$="[[autoValidate]]"
                         required="[[required]]"
                         readonly$="[[readonly]]"
                         disabled$="[[disabled]]"
                         invalid="{{invalid}}">
                <i suffix class="md-icon">arrow_drop_down</i>
            </paper-input>
            <template id="default">
                <style>
                    :host {
                        color: red;
                        background-color: pink;
                    }

                    span {
                        color: green;
                    }
                </style>
                <span class="autocomplete" title="[[_getItemDisplayName(item)]]">[[_getItemDisplayName(item)]]</span>
            </template>
        </vaadin-combo-box-light>
    </template>




    <script>
        /**
         * `type-ahead`
         *
         *
         * @customElement
         * @polymer
         * @demo demo/index.html
         */
        let idx = 1;
        class TypeAhead extends Polymer.Element {
            constructor() {
                super();
                this.ACTION = {
                    OPENED: 'opened',
                    CLOSED: 'closed',
                    CHANGED: 'changed'
                };
                this.lastFilterText = undefined;
            }

            _ensureTemplatized() {
                this._itemTemplate = this.querySelector('template');
                var inputPlaceholder = this.$.combo.querySelector('template#default');
                if (this._itemTemplate && inputPlaceholder) {
                    this.$.combo.replaceChild(this._itemTemplate, inputPlaceholder);
                }
            }

            static get is() { return 'type-ahead'; }
            static get observers() {
                return [
                    '_onFilterTextChanged(filterText)',
                    '_onValueTextChanged(value, text)',
                    '_onDropdownListChanged(dropdownList)',
                    '_onLabelDisplayPathChanged(itemLabelPath,itemDisplayPath)'
                ];
            }
            connectedCallback() {
                super.connectedCallback();
                this._ensureAttribute('always-float-label', '');
                this.$.combo._prefillFocusedItemLabel = () => { return; }

                window['typeAhead' + idx] = this;
                idx++;
                this._ensureTemplatized();
            }
            static get properties() {
                return {
                    label: String,
                    minimumSearchChar: { type: Number, value: 3 },
                    filterText: String,
                    placeholder: String,
                    offset: { type: Number, value: 0 },
                    alwaysFloatLabel: { type: Boolean, value: false },
                    readonly: { type: Boolean, value: false },
                    disabled: { type: Boolean, value: false },
                    invalid: { type: Boolean, value: false },
                    autoValidate: { type: Boolean, value: false },
                    required: { type: Boolean, value: false },
                    filterService: { type: Boolean, value: false },
                    allowCustomValue: { type: Boolean, value: false },
                    items: Array,
                    filteredItems: Array,
                    itemValuePath: String,
                    itemLabelPath: String,
                    itemDisplayPath: String,
                    lastFilterText: String,
                    minimumWidth: String,
                    value: { type: String, notify: true },
                    text: { type: String, notify: true }
                };
            }

            _onPaperInputFocus(e) {
                this.filterService && (this.loading = false);
            }

            _onKeypressed(e) {
                if (!this.$.display.value) {
                    (this.selectedItem || this.$.combo.selectedItem) && this._clearSelectedItem();
                    this._clearFilteredItems();
                }
            }
            _clearSelectedItem() {
                this.setProperties({
                    'itemValue': undefined,
                    'itemLabel': '',
                    'lastFilterText': '',
                    'selectedItem': undefined,
                    '$.combo.selectedItem': undefined
                });
            }
            _clearEventQueue() {
                this.lastFilterText = this.$.display.value;
                this.eventQueue = {};
            }

            _getActionFromEventName(name) {
                return (name.split('-')).pop();
            }

            _handleOpenedChangedClosedEvents() {
                if (this.eventQueue) {
                    const { opened, changed, closed } = this.eventQueue;
                    if (opened && changed && closed) {
                        const { label, value } = this._getItemValueLabel(changed.e.detail.value);
                        if (this.srcOfChanged !== 'top') {
                            this.srcOfChanged = 'bottom';
                            this.setProperties({
                                text: label, value: value,
                                selectedItem: changed.e.detail.value
                            });

                            this._dispatchEvent(changed.e);
                        }
                    }
                    if (closed) {
                        this.lastFilterText = '';
                        this.filterService && this._clearFilteredItems();
                    }
                }
            }

            _onVaadinEventFired(e) {
                if (e) {
                    e.stopPropagation && e.stopPropagation();
                    const { type, detail } = e;
                    let value = detail.value;
                    let action = this._getActionFromEventName(type);
                    if (action === this.ACTION.OPENED) {
                        this._clearEventQueue();
                    }
                    /*Handle when parent set value and label to Vaadin and it is not found in the list*/
                    if (action === this.ACTION.CHANGED &&
                        this.srcOfChanged === 'top') {
                        this.srcOfChanged = undefined;
                    }
                    else {
                        this.srcOfChanged = 'bottom';
                    }
                    if (type === 'custom-value-set') {
                        let tempResult = this._handleCustomValue(e);
                        if (tempResult === false) { return; }
                        else {
                            e.detail = tempResult;
                        }
                        action = 'changed';
                    }
                    else if (action === 'opened') {
                        this._onDropdownOpened();
                    }
                    else if (action === 'closed') {
                        this._onDropdownClosed();
                    }
                    else if (action === 'changed') {
                        if (value === undefined) { e.detail.value = null; }
                    }

                    if (this.eventQueue) {
                        if (!this.eventQueue[action]) {
                            this.eventQueue[action] = {
                                e: e,
                                value: value
                            }
                            this._debounce({
                                id: 'openedChangedClosedEvents',
                                fn: this._handleOpenedChangedClosedEvents
                            });
                        }
                    }
                }
            }

            _handleCustomValue(e) {
                let result = false;
                let value;
                let customValue = e.detail;
                if (this.allowCustomValue) {
                    if (typeof customValue !== 'string') {
                        customValue = null;
                    }
                    if (this.lastCustomValue === customValue) {
                        return false;

                    }
                    this.lastCustomValue = customValue;
                    if ((customValue || '').length > 0) {
                        value = this._createSelectedItem(customValue, customValue);
                        value.isCustomValue = true;
                    }
                    else {
                        value = null;
                    }

                    return { value: value };
                }
                else {
                    let clearSelectedItem = true;
                    if (this.selectedItem) {
                        if (customValue === this._getItemLabel(this.selectedItem)) {
                            clearSelectedItem = false;
                        }
                    }
                    if (clearSelectedItem) {
                        this._clearSelectedItem();
                        return { value: null };
                    }
                    else {
                        return false;
                    }
                }
                return true;
            }

            _onDropdownOpened() {
                this._resizedDropdown();
            }
            _onDropdownClosed() {
                if (this.minimumWidth) {
                    this.$.combo.$.overlay.style.visibility = 'hidden';
                }
            }
            _resizedDropdown() {
                if (this.minimumWidth) {
                    this.$.combo.$.overlay.style.visibility = 'hidden';
                    const body = document.getElementsByTagName('body')[0];
                    const overlayNew = body.querySelector('vaadin-combo-box-overlay');
                    if (overlayNew) {
                        setTimeout(() => {
                            overlayNew.style.minWidth = this.minimumWidth;
                            overlayNew.style.visibility = '';
                            if (this.top10) {
                                overlayNew.classList.add('top10');
                            }
                        }, 100);
                    }
                }
            }
            _onDropdownListChanged(value) {
                if (this.filterService) {
                    this.filteredItems = value;
                    this.loading = false;
                }
                else {
                    this.items = value;
                }
            }

            _onValueTextChanged(value, label) {
                this._debounce({
                    id: 'valueText',
                    fn: this._forceSetValueLabelToVaadin
                });
            }
            _onStaticListFilterTextChanged(text) {
            }

            _onFilterTextChanged(text) {
                if (this.lastFilterText === undefined && text === '') {
                    if (!this._isManualCustomValue()) {
                        this.itemLabel = undefined;
                    }
                    this.invalid = false;
                    return;
                }
                this.filterService && this._onDynamicListFilterTextChanged(text);
            }

            _isManualCustomValue() {
                const label = this.$.display.value;
                const value = this.$.combo.value;
                return label === value && (value || '').length > 0;
            }

            _onDynamicListFilterTextChanged(text) {
                if (text !== undefined && this.lastFilterText !== text) {
                    this._debounce({
                        id: 'filterText', timeout: 400, fn: () => {
                            if (text.length == 0 || (text.length >= this.minimumSearchChar)) {
                                if (text !== this.lastFilterText) {
                                    this.loading = true;
                                    this.lastFilterText = text;
                                    this._clearFilteredItems();
                                    this._dispatchEvent({
                                        type: 'filter-changed',
                                        target: this, detail: { value: text }
                                    });
                                }
                            }
                        }
                    });
                }
            }

            _onBlur(e) {
                this._clearFilteredItems();
            }

            _getItemValueLabel(item) {
                if (item === null || item === undefined) {
                    return { label: item, value: item };
                }
                const label = Polymer.Path.get(item, this.itemLabelPath);
                const value = Polymer.Path.get(item, this.itemValuePath);

                return { label, value };
            }

            _clearFilteredItems() {
                this.filteredItems = undefined;
            }

            _getItemDisplayName(item) {
                return item[this.itemDisplayPath];
            }
            _onLabelDisplayPathChanged() {
                this._debounce({
                    id: 'labelDisplayPath', fn: () => {
                        const { itemLabelPath: label, itemDisplayPath: display } = this;
                        if (label && !display) {
                            this.itemDisplayPath = label;
                        }
                        else if (!label && display) {
                            this.itemLabelPath = display;
                        }
                    }
                });
            }

            _createSelectedItem(value, label) {
                let item = {};
                value && (item[this.itemValuePath] = value);
                label && (item[this.itemLabelPath] = label);

                return item;
            }

            _forceSetValueLabelToVaadin() {
                const value = this.value;
                let label = this.text;
                let item;
                const labelPath = '$.combo._inputElementValue';
                const valuePath = '$.combo.value';
                let vaadinItem = {};

                if (this.srcOfChanged !== 'bottom') {
                    this.srcOfChanged = 'top';
                    let vaadinItem = {};
                    let typeAheadItem = {};

                    if (value) {
                        vaadinItem[valuePath] = value;
                        item = this._findItemByValue(value);
                        if (item) {
                            label = this._getItemLabel(item);
                            vaadinItem['text'] = label;
                        }
                    }
                    if (label) {
                        this.lastCustomValue = label;
                        vaadinItem[labelPath] = label;
                    }

                    if (!item) {
                        item = this._createSelectedItem(value, label);
                        item.fromParent = true;
                    }
                    vaadinItem['selectedItem'] = item;

                    this.setProperties(vaadinItem);
                }
                else {
                    this.srcOfChanged = undefined;
                }
            }

            _getItemLabel(item) {
                return (item || {})[this.itemLabelPath] || '';
            }

            _findItemByValue(value) {
                const idx = this.$.combo._indexOfValue(value, this.$.combo.items);
                if (idx > -1) {
                    return this.$.combo.items[idx];
                }
                return null;
            }

            _debounce({ id, timeout, fn }) {
                if (!timeout) { timeout = 1; }
                const dbId = `dbid-${id}`;
                this[dbId] = Polymer.Debouncer.debounce(this[dbId],
                    Polymer.Async.timeOut.after(timeout),
                    fn.bind(this));
            }

            _getEventName(name) {
                const pair = {
                    'custom-value-set': 'selected-item-changed'
                };
                return pair.hasOwnProperty(name) ? pair[name] : name;
            }

            _dispatchEvent(e) {
                e.stopPropagation && e.stopPropagation();
                const { type, detail } = e;
                const event = new CustomEvent(this._getEventName(type),
                    { bubbles: true, composed: true, detail });
                this.dispatchEvent(event);
            }



            validate() {
                return this.$.display.validate();
            }
        }

        window.customElements.define(TypeAhead.is, TypeAhead);
    </script>
</dom-module>
