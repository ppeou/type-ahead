<link rel="import" href="../bower_components/polymer/polymer-element.html">
<link rel="import" href="../bower_components/polymer/lib/utils/debounce.html">
<link rel="import" href="../bower_components/vaadin-combo-box/vaadin-combo-box-light.html">
<link rel="import" href="../bower_components/paper-input/paper-input.html">
<link rel="import" href="md-icons.html">
<link rel="import" href="type-ahead-style.html">
<dom-module id="type-ahead">
    <template>
        <style include="type-ahead-style md-icons">
            :host {
                display: block;
            }

                :host[hidden], :host.hidden {
                    display: none;
                }
        </style>
        <vaadin-combo-box-light id="combo"
                                attr-for-value="value"
                                filter="{{filterText}}"
                                allow-custom-value
                                on-blur="_onBlur"
                                value="{{itemValue}}"
                                loading="[[loading]]"
                                overlay-vertical-offset="[[overlayVerticalOffset]]"
                                filtered-items="[[filteredItems]]"
                                items="[[items]]"
                                item-value-path="[[itemValuePath]]"
                                item-label-path="[[itemLabelPath]]"
                                item-display-path="[[itemDisplayPath]]"
                                hidden$="[[hidden]]"
                                on-custom-value-set="_onVaadinEventFired"
                                on-selected-item-changed="_onVaadinEventFired"
                                on-vaadin-dropdown-closed="_onVaadinEventFired"
                                on-vaadin-dropdown-opened="_onVaadinEventFired">

            <paper-input id="display"
                         label="[[label]]"
                         value="{{itemLabel}}"
                         on-keyup="_onKeypressed"
                         on-focus="_onPaperInputFocus"
                         no-label-float="[[noLabelFloat]]"
                         always-float-label="[[alwaysFloatLabel]]"
                         placeholder$="[[placeholder]]"
                         auto-validate$="[[autoValidate]]"
                         required="[[required]]"
                         disabled$="[[disabled]]"
                         invalid="{{invalid}}">
                <i suffix class="md-icon">arrow_drop_down</i>
            </paper-input>
            <template>
                <style>
                    :host {
                        color: red;
                    }
                </style>
                <span title="[[_getItemDisplayName(item)]]">[[_getItemDisplayName(item)]]</span>
            </template>
        </vaadin-combo-box-light>
    </template>
    <script>
        /**
         * `type-ahead`
         *
         *
         * @customElement
         * @polymer
         * @demo demo/index.html
         */
        let idx = 1;
        class TypeAhead extends Polymer.Element {
            constructor() {
                super();
                this.ACTION = {
                    OPENED: 'opened',
                    CLOSED: 'closed',
                    CHANGED: 'changed'
                };
                this.lastFilterText = undefined;
            }
            static get is() { return 'type-ahead'; }
            static get observers() {
                return [
                    '_onFilterTextChanged(filterText)',
                    '_onValueTextChanged(value, text)',
                    '_onDropdownListChanged(dropdownList)',
                    '_onLabelDisplayPathChanged(itemLabelPath,itemDisplayPath)'
                ];
            }
            connectedCallback() {
                super.connectedCallback();
                this._ensureAttribute('always-float-label', '');
                this.$.combo._prefillFocusedItemLabel = () => { return; }

                window['typeAhead' + idx] = this;
                idx++;
            }
            static get properties() {
                return {
                    label: String,
                    minimumSearchChar: { type: Number, value: 3 },
                    filterText: String,
                    placeholder: String,
                    alwaysFloatLabel: { type: Boolean, value: false },
                    disabled: { type: Boolean, value: false },
                    invalid: { type: Boolean, value: false },
                    autoValidate: { type: Boolean, value: false },
                    required: { type: Boolean, value: false },
                    filterService: { type: Boolean, value: false },
                    allowCustomValue: { type: Boolean, value: false },
                    items: Array,
                    filteredItems: Array,
                    itemValuePath: String,
                    itemLabelPath: String,
                    itemDisplayPath: String,
                    lastFilterText: String,
                    minimumWidth: String,
                    value: { type: String, notify: true },
                    text: { type: String, notify: true }
                };
            }

            _onPaperInputFocus(e) {
                this.filterService && (this.loading = false);
            }

            _onKeypressed(e) {
                if (!this.$.display.value) {
                    (this.selectedItem || this.$.combo.selectedItem) && this._clearSelectedItem();
                    this._clearFilteredItems();
                }
            }
            _clearSelectedItem() {
                this.setProperties({
                    'itemValue': undefined,
                    'itemLabel': '',
                    'lastFilterText': '',
                    'selectedItem': undefined,
                    '$.combo.selectedItem': undefined
                });
            }
            _clearEventQueue() {
                this.lastFilterText = this.$.display.value;
                this.eventQueue = {};
            }

            _getActionFromEventName(name) {
                return (name.split('-')).pop();
            }

            _handleOpenedChangedClosedEvents() {
                if (this.eventQueue) {
                    const { opened, changed, closed} = this.eventQueue;                    
                    if (opened && changed && closed) {                        
                        const { label, value } = this._getItemValueLabel(changed.value);
                        if (this.srcOfChanged !== 'top') {
                            this.srcOfChanged = 'bottom';
                            this.setProperties({
                                text: label, value: value,
                                selectedItem: changed.value
                            });
                            
                            this._dispatchEvent(changed.e);
                        }
                    }
                    if (closed) {
                        this.lastFilterText = '';
                        this.filterService && this._clearFilteredItems();
                    }
                }
            }

            _onVaadinEventFired(e) {
                if (e) {
                    e.stopPropagation && e.stopPropagation();
                    const { type, detail } = e;
                    let value = detail.value;
                    let action = this._getActionFromEventName(type);
                    if (action === this.ACTION.OPENED) {
                        this._clearEventQueue();
                    }                   
                    /*Handle when parent set value and label to Vaadin and it is not found in the list*/
                    if (action === this.ACTION.CHANGED &&
                        this.srcOfChanged === 'top') {
                        this.srcOfChanged = undefined;
                    }
                    else {
                        this.srcOfChanged = 'bottom';
                    }
                    console.log(action, value);
                    if (type === 'custom-value-set') {                        
                        let customValue = e.detail;                        
                        if (this.allowCustomValue) {
                            if (typeof customValue !== 'string') {
                                customValue = null;
                            }
                            if (this.lastCustomValue === customValue) {
                                return;
                            }
                            this.lastCustomValue = customValue;
                            if ((customValue || '').length > 0) {
                                value = this._createSelectedItem(customValue, customValue);
                                value.isCustomValue = true;                                                   
                            }
                            else {
                                value = null;
                            }

                            e.detail = { value: value };
                            console.log('>>', action, value);
                            action = 'changed';             
                        }                        
                    }

                    
                    if (this.eventQueue) {
                        if (!this.eventQueue[action]) {
                            this.eventQueue[action] = {
                                e: e,
                                value: value
                            }
                            this._debounce({
                                id: 'openedChangedClosedEvents',
                                fn: this._handleOpenedChangedClosedEvents
                            });
                        }
                    }
                }
            }

            _onDropdownListChanged(value) {
                if (this.filterService) {
                    this.filteredItems = value;
                    this.loading = false;
                }
                else {
                    this.items = value;
                }
            }

            _onValueTextChanged(value, label) {
                this._debounce({
                    id: 'valueText',
                    //fn: this._forceSetValueLabelToVaadin.bind(this, value, label)
                    fn: this._forceSetValueLabelToVaadin
                });
            }
            _onStaticListFilterTextChanged(text) {
            }

            _onFilterTextChanged(text) {
                if (this.lastFilterText === undefined && text === '') {
                    if (!this._isManualCustomValue()) {
                        this.itemLabel = undefined;
                    }
                    this.invalid = false;
                    return;
                }
                this.filterService && this._onDynamicListFilterTextChanged(text);
            }

            _isManualCustomValue() {
                const label = this.$.display.value;
                const value = this.$.combo.value;
                return label === value && (value || '').length > 0;
            }

            _onDynamicListFilterTextChanged(text) {                
                if (text !== undefined && this.lastFilterText !== text) {
                    this._debounce({
                        id: 'filterText', timeout: 400, fn: () => {
                            if (text.length == 0 || (text.length >= this.minimumSearchChar)) {
                                if (text !== this.lastFilterText) {
                                    this.loading = true;
                                    this.lastFilterText = text;
                                    this._clearFilteredItems();
                                    this._dispatchEvent({
                                        type: 'filter-changed',
                                        target: this, detail: { value: text }
                                    });
                                }
                            }
                        }
                    });
                }
            }

            _onBlur(e) {
                this._clearFilteredItems();
            }

            _getItemValueLabel(item) {
                const label = Polymer.Path.get(item, this.itemLabelPath);
                const value = Polymer.Path.get(item, this.itemValuePath);

                return { label, value };
            }

            _clearFilteredItems() {
                this.filteredItems = undefined;
            }

            _getItemDisplayName(item) {
                return item[this.itemDisplayPath];
            }
            _onLabelDisplayPathChanged() {
                this._debounce({
                    id: 'labelDisplayPath', fn: () => {
                        const { itemLabelPath: label, itemDisplayPath: display } = this;
                        if (label && !display) {
                            this.itemDisplayPath = label;
                        }
                        else if (!label && display) {
                            this.itemLabelPath = display;
                        }
                    }
                });
            }

            _createSelectedItem(value, lable) {
                let item = {};
                value && (item[this.itemValuePath] = value);
                lable && (item[this.itemLabelPath] = lable);

                return item;
            }

            _forceSetValueLabelToVaadin() {
                const value = this.value;
                const label = this.text;
                const labelPath = '$.combo._inputElementValue';
                const valuePath = '$.combo.value';
                let vaadinItem = {};

                if (this.srcOfChanged !== 'bottom') {
                    this.srcOfChanged = 'top';
                    let vaadinItem = {};
                    let typeAheadItem = {};
                    let item = this._createSelectedItem(value, label);
                    item.fromParent = true;                    
                    vaadinItem['selectedItem'] = item;
                    if (value) {
                        vaadinItem[valuePath] = value;
                    }
                    if (label) {
                        vaadinItem[labelPath] = label;
                    }
                    
                    this.setProperties(vaadinItem);
                }
                else {
                    this.srcOfChanged = undefined;
                }
            }

            _debounce({ id, timeout, fn }) {
                if (!timeout) { timeout = 1; }
                const dbId = `dbid-${id}`;
                this[dbId] = Polymer.Debouncer.debounce(this[dbId],
                    Polymer.Async.timeOut.after(timeout),
                    fn.bind(this));
            }
            _dispatchEvent(e) {
                e.stopPropagation && e.stopPropagation();
                const { type, detail } = e;
                const event = new CustomEvent(type,
                    { bubbles: true, composed: true, detail });
                this.dispatchEvent(event);
            }
            validate() {
                return this.$.display.validate();
            }
        }

        window.customElements.define(TypeAhead.is, TypeAhead);
    </script>
</dom-module>
